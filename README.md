# RemoteGitHub

Get familiar with git and GitHub

## 项目文件介绍

1. Peple相关文件是关于peple类的实现与操作
2. Array相关文件是关于array模板类的实现与操作

## 项目文件相关笔记

1. Peple相关笔记——类
    - 编程习惯：类定义放在.h文件中，类声明放在.cpp文件中
    - 类成员函数声明未定义错误
        + 构造函数或则析构函数，如果声明未定义，又声明了这个类的实例一定会报错
        + 其它函数，只有在被调用时才会报错
    - 类访问修饰符
        + 公有修饰符(public)
        + 私有修饰符(private)
        + 受保护修饰符(protected)
    - 累继承有三种类型：public、private、protected
    - new:新建一个对象，new运算符总是返回一个指针

2. Array相关笔记——模板类
    - 编程习惯(要求)： **模板类不支持声明(.h)和实现(.cpp)分开写**
    - 模板类成员声明未定义错误
    - elemType:元素类型——一个抽象概念
    - 类模板写法
    - 类模板成员函数写法
    - 类模板定义对象写法
    - 虚拟函数、纯虚函数
    - 操作符重载


3. String相关笔记
    - 函数重载
    - 缺省构造函数、拷贝构造函数
    - 操作符重载
        + 形式：return_type operator op (parameter_list);
        + 例如：char& operator[](int);
    - 当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。
    - this 关键字，他是一个指针，要用 -> 去操作成员变量或成员方法

4. Stack相关笔记
    - C++之构造函数的初始化参数表
        + 对于常量类型（const int a)和引用类型(int& a)的数据成员,不能在构造函数中用赋值语句直接赋值,C++提供初始化表进行置初值。
        + 类名::构造函数名([参数表]):(成员初始化表){ // 构造函数体 }
        + 使用初始化列表有两个原因
            * 原因1.必须这样做：
                1. 需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化);
                2. 需要初始化const修饰的类成员;
                3. 需要初始化引用成员数据;
            * 原因2.效率要求这样做：
              > 类对象的构造顺序显示，进入构造函数体后，进行的是计算，是对成员变量的赋值操作，显然，赋值和初始化是不同的，这样就体现
              > 出了效率差异，如果不用成员初始化类表，那么类对自己的类成员分别进行的是一次隐式的默认构造函数的调用，和一次赋值操作符
              > 的调用，如果是类对象，这样做效率就得不到保障。注意：构造函数需要初始化的数据成员，不论是否显示的出现在构造函数的成员
              > 初始化列表中，都会在该处完成初始化，并且初始化的顺序和其在类中声明时的顺序是一致的，与列表的先后顺序无关，所以要特别
              > 注意，保证两者顺序一致才能真正保证其效率和准确性。
              [C++之构造函数的初始化参数表](https://blog.csdn.net/weixin_45746505/article/details/127907317#:~:text=%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F%E4%B8%BA%EF%BC%9A%20%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%8D1,%28%E5%88%9D%E5%A7%8B%E5%80%BC1%29%2C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%8D2%20%28%E5%88%9D%E5%A7%8B%E5%80%BC2%29%2C%E2%80%A6%E2%80%A6%201)

5. List相关笔记
    - 单链表的实现方式
    - 内联函数
